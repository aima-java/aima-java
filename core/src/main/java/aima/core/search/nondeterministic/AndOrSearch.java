package aima.core.search.nondeterministic;


/**
 * Artificial Intelligence A Modern Approach (3rd Edition): Figure 4.11, page
 * 136.<br>
 * <br>
 * 
 * <pre>
 * <code>
 * function AND-OR-GRAPH-SEARCH(problem) returns a conditional plan, or failure
 *   OR-SEARCH(problem.INITIAL-STATE, problem, [])
 * 
 * ---------------------------------------------------------------------------------
 * 
 * function OR-SEARCH(state, problem, path) returns a conditional plan, or failure
 *   if problem.GOAL-TEST(state) then return the empty plan
 *   if state is on path then return failure
 *   for each action in problem.ACTIONS(state) do
 *       plan <- AND-SEARCH(RESULTS(state, action), problem, [state | path])
 *       if plan != failure then return [action | plan]
 *   return failure
 * 
 * ---------------------------------------------------------------------------------
 * 
 * function AND-SEARCH(states, problem, path) returns a conditional plan, or failure
 *   for each s<sub>i</sub> in states do
 *      plan<sub>i</sub> <- OR-SEARCH(s<sub>i</sub>, problem, path)
 *      if plan<sub>i</sub> = failure then return failure
 *   return [if s<sub>1</sub> then plan<sub>1</sub> else if s<sub>2</sub> then plan<sub>2</sub> else ... if s<sub>n-1</sub> then plan<sub>n-1</sub> else plan<sub>n</sub>]
 * </code>
 * </pre>
 * 
 * Figure 4.11 An algorithm for searching AND-OR graphs generated by
 * nondeterministic environments. It returns a conditional plan that reaches a
 * goal state in all circumstances. (The notation [x | l] refers to the list
 * formed by adding object x to the front of the list l.)<br>
 * <br>
 * Note: Unfortunately, this class cannot implement the interface Search
 * (core.search.framework.Search) because Search.search() returns a list of
 * Actions to perform, whereas a nondeterministic search must return a Plan.
 * 
 * @author Anurag Rai
 */
import java.util.ArrayList;
import java.util.List;

import aima.core.api.search.nondeterministic.AndSearch;
import aima.core.api.search.nondeterministic.NondeterministicProblem;
import aima.core.api.search.nondeterministic.OrSearch;

public class AndOrSearch<A, S> implements OrSearch<A, S> {

	private AndSearch<A, S> andSearch;
	private OrSearch<A, S> orSearch;
	
	public AndSearch<A, S> andSearch() {
		return andSearch; 
	}
	
	public OrSearch<A, S> orSearch() {
		return orSearch; 
	}

	@Override
	public Plan<A> apply(NondeterministicProblem<A, S> problem) {
		List<S> path = new ArrayList<>();
		return orSearch.apply(problem.initialState(),problem,path);
	}

}
